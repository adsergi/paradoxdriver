/*
 * Copyright (C) 2009 Leonardo Alves da Costa
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any
 * later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
 * even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 * License for more details. You should have received a copy of the GNU General Public License along with this
 * program. If not, see <http://www.gnu.org/licenses/>.
 */
package com.googlecode.paradox;

import com.googlecode.paradox.exceptions.ParadoxDataException;
import com.googlecode.paradox.exceptions.ParadoxException;
import com.googlecode.paradox.exceptions.ParadoxNotSupportedException;
import com.googlecode.paradox.exceptions.ParadoxSyntaxErrorException;
import com.googlecode.paradox.parser.SQLParser;
import com.googlecode.paradox.parser.nodes.StatementNode;
import com.googlecode.paradox.planner.Planner;
import com.googlecode.paradox.planner.plan.Plan;
import com.googlecode.paradox.planner.plan.SelectPlan;
import com.googlecode.paradox.utils.Utils;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.List;

/**
 * PreparedStatement implementation class.
 *
 * @version 1.0
 * @since 1.6.0
 */
final class ParadoxPreparedStatement implements PreparedStatement {

    /**
     * The Paradox connection.
     */
    private final ParadoxConnection connection;
    /**
     * Auto generated keys.
     */
    private final int autoGeneratedKeys;
    /**
     * Statement list.
     */
    private final List<StatementNode> statements = new ArrayList<>();
    /**
     * ResultSet list.
     */
    private final List<ResultSet> resultSets = new ArrayList<>();
    /**
     * Parameter list.
     */
    private final Object[] parameterList;
    /**
     * Execution list.
     */
    private final List<Object[]> executions = new ArrayList<>();
    /**
     * If this statement is capable of pooling;
     */
    private boolean pool = true;
    /**
     * Statement closed.
     */
    private boolean closed;
    /**
     * Close on completion.
     */
    private boolean closeOnCompletion;
    /**
     * Result set concurrency.
     */
    private int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
    /**
     * Result set type.
     */
    private int resultSetType = ResultSet.TYPE_SCROLL_INSENSITIVE;
    /**
     * Result set holdability.
     */
    private int resultSetHoldability;
    /**
     * Result set index.
     */
    private int resultSetIndex = -1;

    /**
     * Creates a new instance.
     *
     * @param connection the Paradox connection.
     */
    public ParadoxPreparedStatement(final ParadoxConnection connection, final String sql,
                                    final int autoGeneratedKeys) throws SQLException {
        this.connection = connection;
        this.autoGeneratedKeys = autoGeneratedKeys;

        final SQLParser parser = new SQLParser(connection, sql);
        statements.addAll(parser.parse());

        if (statements.isEmpty()) {
            throw new ParadoxSyntaxErrorException(ParadoxSyntaxErrorException.Error.EMPTY_SQL);
        } else if (statements.size() > 1) {
            throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.USE_BATCH_OPERATION);
        }

        parameterList = new Object[statements.get(0).getParameterCount()];
    }

    @Override
    public ResultSet executeQuery() throws SQLException {
        if (statements.size() != 1 || !executions.isEmpty()) {
            throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.USE_BATCH_OPERATION);
        }

        executions.add(parameterList);
        executeStatements();

        resultSetIndex = 0;
        return getResultSet();
    }

    private int[] executeStatements() throws SQLException {
        // Close all existing result sets.
        for (final ResultSet rs : resultSets) {
            rs.close();
        }

        resultSets.clear();

        ArrayList<Integer> ret = new ArrayList<>();
        // One for statement.
        for (final StatementNode statement : statements) {
            final Plan plan = Planner.create(connection, statement);

            // One for parameters.
            for (final Object[] params : executions) {
                // FIXME use parameterList.
                plan.execute(this.connection);

                if (plan instanceof SelectPlan) {
                    final ParadoxResultSet resultSet = new ParadoxResultSet(this.connection, this,
                            ((SelectPlan) plan).getValues(), ((SelectPlan) plan).getColumns());
                    resultSet.setFetchDirection(ResultSet.FETCH_FORWARD);
                    // FIXME type and concurrency type.

                    ret.add(Statement.SUCCESS_NO_INFO);
                    resultSets.add(resultSet);
                }
            }
        }

        int[] values = new int[ret.size()];
        for (int loop = 0; loop < ret.size(); loop++) {
            values[loop] = ret.get(loop);
        }
        return values;
    }

    @Override
    public int executeUpdate() throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setNull(int parameterIndex, int sqlType) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = null;
    }

    @Override
    public void setBoolean(int parameterIndex, boolean x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setByte(int parameterIndex, byte x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setShort(int parameterIndex, short x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setInt(int parameterIndex, int x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setLong(int parameterIndex, long x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setFloat(int parameterIndex, float x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setDouble(int parameterIndex, double x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setString(int parameterIndex, String x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setBytes(int parameterIndex, byte[] x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setDate(int parameterIndex, Date x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setTime(int parameterIndex, Time x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    /**
     * {@inheritDoc}.
     *
     * @deprecated to keep compatibility.
     */
    @Deprecated
    @Override
    public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void clearParameters() {
        Arrays.fill(parameterList, null);
    }

    @Override
    public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setObject(int parameterIndex, Object x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public boolean execute() throws SQLException {
        return false;
    }

    @Override
    public void addBatch() {
        executions.add(parameterList);
    }

    @Override
    public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setRef(int parameterIndex, Ref x) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setBlob(int parameterIndex, Blob x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setClob(int parameterIndex, Clob x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setArray(int parameterIndex, Array x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public ResultSetMetaData getMetaData() throws SQLException {
        final ResultSet current = getResultSet();
        if (current != null) {
            return current.getMetaData();
        }

        return null;
    }

    @Override
    public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = null;
    }

    @Override
    public void setURL(int parameterIndex, URL x) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public ParameterMetaData getParameterMetaData() throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setRowId(int parameterIndex, RowId x) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setNString(int parameterIndex, String value) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setNClob(int parameterIndex, NClob value) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
        checkIndex(parameterIndex);
        parameterList[parameterIndex - 1] = x;
    }

    @Override
    public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setClob(int parameterIndex, Reader reader) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void setNClob(int parameterIndex, Reader reader) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        return null;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void close() throws SQLException {
        for (final ResultSet rs : resultSets) {
            rs.close();
        }

        this.closed = true;
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        return 0;
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {

    }

    @Override
    public int getMaxRows() throws SQLException {
        // FIXME max rows.
        return 0;
    }

    @Override
    public void setMaxRows(int max) throws SQLException {

    }

    @Override
    public void setEscapeProcessing(boolean enable) {
        // Nothing to do here.
    }

    @Override
    public int getQueryTimeout() {
        return 0;
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public void cancel() throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public SQLWarning getWarnings() {
        return null;
    }

    @Override
    public void clearWarnings() {
        // Nothing to do here.
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public ResultSet getResultSet() {
        if (resultSetIndex != -1 && resultSetIndex < resultSets.size()) {
            return resultSets.get(resultSetIndex);
        }

        return null;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        return 0;
    }

    @Override
    public boolean getMoreResults() {
        if (resultSetIndex < resultSets.size()) {
            resultSetIndex++;
            return true;
        }

        return false;
    }

    @Override
    public int getFetchDirection() throws SQLException {
        final ResultSet resultSet = getResultSet();
        if (resultSet != null) {
            return resultSet.getFetchDirection();
        }

        throw new ParadoxDataException(ParadoxDataException.Error.NO_RESULT_SET_AVAILABLE);
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        final ResultSet resultSet = getResultSet();
        if (resultSet != null) {
            resultSet.setFetchDirection(direction);
        }

        throw new ParadoxDataException(ParadoxDataException.Error.NO_RESULT_SET_AVAILABLE);
    }

    @Override
    public int getFetchSize() throws SQLException {
        final ResultSet resultSet = getResultSet();
        if (resultSet != null) {
            return resultSet.getFetchSize();
        }

        throw new ParadoxDataException(ParadoxDataException.Error.NO_RESULT_SET_AVAILABLE);
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        final ResultSet resultSet = getResultSet();
        if (resultSet != null) {
            resultSet.setFetchSize(rows);
        }

        throw new ParadoxDataException(ParadoxDataException.Error.NO_RESULT_SET_AVAILABLE);
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        final ResultSet resultSet = getResultSet();
        if (resultSet != null) {
            return resultSet.getConcurrency();
        }

        throw new ParadoxDataException(ParadoxDataException.Error.NO_RESULT_SET_AVAILABLE);
    }

    public void setResultSetConcurrency(int resultSetConcurrency) {
        this.resultSetConcurrency = resultSetConcurrency;
    }

    @Override
    public int getResultSetType() throws SQLException {
        final ResultSet resultSet = getResultSet();
        if (resultSet != null) {
            return resultSet.getType();
        }

        throw new ParadoxDataException(ParadoxDataException.Error.NO_RESULT_SET_AVAILABLE);
    }

    public void setResultSetType(int resultSetType) {
        this.resultSetType = resultSetType;
    }

    @Override
    public void addBatch(final String sql) throws SQLException {
        final SQLParser parser = new SQLParser(connection, sql);
        final List<StatementNode> batchStatements = parser.parse();

        for (final StatementNode statement : batchStatements) {
            if (statement.getParameterCount() != parameterList.length) {
                throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.INCONSISTENT_PARAMETER_LIST);
            }
        }

        this.statements.addAll(batchStatements);
    }

    @Override
    public void clearBatch() {
        this.executions.clear();
        while (this.statements.size() > 1) {
            this.statements.remove(1);
        }
    }

    @Override
    public int[] executeBatch() throws SQLException {
        return executeStatements();
    }

    @Override
    public Connection getConnection() {
        return connection;
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {
        switch (current) {
            case Statement.CLOSE_CURRENT_RESULT:
                ResultSet currentResult = getResultSet();
                if (currentResult != null) {
                    currentResult.close();
                }
                break;

            case Statement.CLOSE_ALL_RESULTS:
                for (final ResultSet rs : resultSets) {
                    rs.close();
                }
                break;

            case Statement.KEEP_CURRENT_RESULT:
                // Do nothing.
                break;
        }

        return getMoreResults();
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        return null;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        throw new ParadoxNotSupportedException(ParadoxNotSupportedException.Error.OPERATION_NOT_SUPPORTED);
    }

    @Override
    public int getResultSetHoldability() {
        return resultSetHoldability;
    }

    public void setResultSetHoldability(int resultSetHoldability) {
        this.resultSetHoldability = resultSetHoldability;
    }

    @Override
    public boolean isClosed() {
        return closed;
    }

    @Override
    public boolean isPoolable() {
        return pool;
    }

    @Override
    public void setPoolable(boolean pool) {
        this.pool = pool;
    }

    @Override
    public void closeOnCompletion() {
        this.closeOnCompletion = true;
    }

    @Override
    public boolean isCloseOnCompletion() {
        return closeOnCompletion;
    }

    @Override
    public <T> T unwrap(Class<T> iFace) throws SQLException {
        return Utils.unwrap(this, iFace);
    }

    @Override
    public boolean isWrapperFor(Class<?> iFace) {
        return Utils.isWrapperFor(this, iFace);
    }

    private void checkIndex(final int index) throws ParadoxException {
        if (index < 1 || index > parameterList.length) {
            throw new ParadoxException(ParadoxException.Error.INVALID_COLUMN_INDEX, Integer.toString(index), null);
        }
    }
}